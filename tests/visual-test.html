<!DOCTYPE html>
<html>

<head>
    <title>Visual Smoke Test</title>
</head>

<body>
    <canvas id="test-canvas" width="800" height="600"></canvas>
    <script>
        const { ipcRenderer } = require('electron');
        const path = require('path');

        // Mock Logger if needed, or rely on the real one if it works
        // The real logger uses ipcRenderer.send('log:renderer', ...), which we haven't handled in run-test.js
        // Let's mock it to be safe and redirect to our 'log' channel
        const mockLogger = {
            log: (msg) => ipcRenderer.send('log', msg),
            error: (msg) => ipcRenderer.send('log', 'ERROR: ' + msg),
            warn: (msg) => ipcRenderer.send('log', 'WARN: ' + msg)
        };

        // We need to intercept require('./logger') in webgl-renderer.js
        // Since we can't easily mock require in this environment without more setup,
        // let's hope the real logger works or fails gracefully.
        // Actually, the real logger is simple. Let's just handle 'log:renderer' in the main process.
        // But wait, we can't easily change the main process handling for 'log:renderer' without changing run-test.js
        // Let's update run-test.js to handle 'log:renderer' as well.

        try {
            const WebGLRenderer = require('../renderer/webgl-renderer.js');

            const canvas = document.getElementById('test-canvas');
            const renderer = new WebGLRenderer(canvas);

            // Create a dummy texture (white noise) to render
            const width = 800;
            const height = 600;
            const buffer = new Uint8ClampedArray(width * height * 4);
            for (let i = 0; i < buffer.length; i += 4) {
                buffer[i] = 255;     // R
                buffer[i + 1] = 255; // G
                buffer[i + 2] = 255; // B
                buffer[i + 3] = 255; // A
            }
            const imageData = new ImageData(buffer, width, height);
            renderer.uploadTexture(imageData);

            // Helper to capture frame data
            const captureFrame = () => {
                const gl = renderer.gl;
                const pixels = new Uint8Array(width * height * 4);
                gl.readPixels(0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
                return pixels;
            };

            // Helper to compare frames (returns % difference)
            const compareFrames = (pixelsA, pixelsB) => {
                let diffCount = 0;
                for (let i = 0; i < pixelsA.length; i += 4) {
                    // Compare RGB only
                    if (Math.abs(pixelsA[i] - pixelsB[i]) > 5 ||
                        Math.abs(pixelsA[i + 1] - pixelsB[i + 1]) > 5 ||
                        Math.abs(pixelsA[i + 2] - pixelsB[i + 2]) > 5) {
                        diffCount++;
                    }
                }
                return diffCount / (width * height);
            };

            // --- TEST 1: Basic Visibility ---
            renderer.render(
                width, height, width / 2, height / 2, 150, 1.33,
                0.5, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, width / 2, height / 2, 0.0
            );
            const frameBasic = captureFrame();

            let nonBlackCount = 0;
            for (let i = 0; i < frameBasic.length; i += 4) {
                if (frameBasic[i] > 10 || frameBasic[i + 1] > 10 || frameBasic[i + 2] > 10) nonBlackCount++;
            }
            const coverage = nonBlackCount / (width * height);

            if (coverage === 0) {
                throw new Error('Test 1 Failed: Output is completely black');
            }
            ipcRenderer.send('log', `Test 1 Passed: Visibility coverage ${(coverage * 100).toFixed(2)}%`);

            // --- TEST 2: Distortion Application ---
            // Render with NO intensity
            renderer.render(
                width, height, width / 2, height / 2, 150, 1.33,
                0.0, // Intensity 0
                0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, width / 2, height / 2, 0.0
            );
            const frameNoDistortion = captureFrame();

            // Render with HIGH intensity
            renderer.render(
                width, height, width / 2, height / 2, 150, 1.33,
                0.8, // Intensity 0.8
                0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, width / 2, height / 2, 0.0
            );
            const frameHighDistortion = captureFrame();

            const distortionDiff = compareFrames(frameNoDistortion, frameHighDistortion);
            if (distortionDiff < 0.01) { // Expect at least 1% pixels to change
                throw new Error(`Test 2 Failed: Changing intensity did not affect image (diff: ${distortionDiff})`);
            }
            ipcRenderer.send('log', `Test 2 Passed: Distortion applied (diff: ${(distortionDiff * 100).toFixed(2)}%)`);

            // --- TEST 3: Motion Responsiveness ---
            // Render at Left position
            renderer.render(
                width, height,
                200, height / 2, // Mouse Left
                150, 1.33, 0.5, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
                200, height / 2, 0.0
            );
            const frameLeft = captureFrame();

            // Render at Right position
            renderer.render(
                width, height,
                600, height / 2, // Mouse Right
                150, 1.33, 0.5, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
                600, height / 2, 0.0
            );
            const frameRight = captureFrame();

            const motionDiff = compareFrames(frameLeft, frameRight);
            if (motionDiff < 0.05) { // Expect significant change
                throw new Error(`Test 3 Failed: Moving mouse did not affect image (diff: ${motionDiff})`);
            }
            ipcRenderer.send('log', `Test 3 Passed: Motion detected (diff: ${(motionDiff * 100).toFixed(2)}%)`);

            // All passed
            ipcRenderer.send('test-result', { success: true, message: 'All visual tests passed' });

        } catch (err) {
            ipcRenderer.send('test-result', {
                success: false,
                message: err.message,
                details: err.stack
            });
        }
    </script>
</body>

</html>