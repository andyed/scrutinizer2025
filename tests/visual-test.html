<!DOCTYPE html>
<html>

<head>
    <title>Visual Smoke Test</title>
</head>

<body>
    <canvas id="test-canvas" width="800" height="600"></canvas>
    <script>
        const { ipcRenderer } = require('electron');
        const path = require('path');

        // Mock Logger if needed, or rely on the real one if it works
        // The real logger uses ipcRenderer.send('log:renderer', ...), which we haven't handled in run-test.js
        // Let's mock it to be safe and redirect to our 'log' channel
        const mockLogger = {
            log: (msg) => ipcRenderer.send('log', msg),
            error: (msg) => ipcRenderer.send('log', 'ERROR: ' + msg),
            warn: (msg) => ipcRenderer.send('log', 'WARN: ' + msg)
        };

        // We need to intercept require('./logger') in webgl-renderer.js
        // Since we can't easily mock require in this environment without more setup,
        // let's hope the real logger works or fails gracefully.
        // Actually, the real logger is simple. Let's just handle 'log:renderer' in the main process.
        // But wait, we can't easily change the main process handling for 'log:renderer' without changing run-test.js
        // Let's update run-test.js to handle 'log:renderer' as well.

        try {
            const WebGLRenderer = require('../renderer/webgl-renderer.js');

            const canvas = document.getElementById('test-canvas');
            const renderer = new WebGLRenderer(canvas);

            // Create a dummy texture (white noise) to render
            const width = 800;
            const height = 600;
            const buffer = new Uint8ClampedArray(width * height * 4);
            for (let i = 0; i < buffer.length; i += 4) {
                buffer[i] = 255;     // R
                buffer[i + 1] = 255; // G
                buffer[i + 2] = 255; // B
                buffer[i + 3] = 255; // A
            }
            const imageData = new ImageData(buffer, width, height);
            renderer.uploadTexture(imageData);

            // Helper to capture frame data
            const captureFrame = () => {
                const gl = renderer.gl;
                const pixels = new Uint8Array(width * height * 4);
                gl.readPixels(0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
                return pixels;
            };

            // Helper to compare frames (returns % difference)
            const compareFrames = (pixelsA, pixelsB) => {
                let diffCount = 0;
                for (let i = 0; i < pixelsA.length; i += 4) {
                    // Compare RGB only
                    if (Math.abs(pixelsA[i] - pixelsB[i]) > 5 ||
                        Math.abs(pixelsA[i + 1] - pixelsB[i + 1]) > 5 ||
                        Math.abs(pixelsA[i + 2] - pixelsB[i + 2]) > 5) {
                        diffCount++;
                    }
                }
                return diffCount / (width * height);
            };

            // --- TEST 1: Basic Visibility ---
            renderer.render(
                width, height, width / 2 + 50, height / 2, 150, 1.33,
                0.5, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, width / 2 + 50, height / 2, 0.0, 1.0
            );
            const frameBasic = captureFrame();

            let nonBlackCount = 0;
            for (let i = 0; i < frameBasic.length; i += 4) {
                if (frameBasic[i] > 10 || frameBasic[i + 1] > 10 || frameBasic[i + 2] > 10) nonBlackCount++;
            }
            const coverage = nonBlackCount / (width * height);

            if (coverage === 0) {
                throw new Error('Test 1 Failed: Output is completely black');
            }
            ipcRenderer.send('log', `Test 1 Passed: Visibility coverage ${(coverage * 100).toFixed(2)}%`);

            // --- TEST 2: Robust Zonal Distortion ---
            // Render with NO intensity
            renderer.render(
                width, height, width / 2, height / 2, 150, 1.33,
                0.0, // Intensity 0
                0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, width / 2, height / 2, 0.0
            );
            const frameNoDistortion = captureFrame();

            // Render with HIGH intensity
            renderer.render(
                width, height, width / 2, height / 2, 150, 1.33,
                0.8, // Intensity 0.8
                0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, width / 2, height / 2, 0.0
            );
            const frameHighDistortion = captureFrame();

            // Helper to check region difference
            const checkRegionDiff = (x, y, w, h, name) => {
                let diffCount = 0;
                let totalPixels = 0;
                for (let ry = y; ry < y + h; ry++) {
                    for (let rx = x; rx < x + w; rx++) {
                        const i = (ry * width + rx) * 4;
                        if (Math.abs(frameNoDistortion[i] - frameHighDistortion[i]) > 5 ||
                            Math.abs(frameNoDistortion[i + 1] - frameHighDistortion[i + 1]) > 5 ||
                            Math.abs(frameNoDistortion[i + 2] - frameHighDistortion[i + 2]) > 5) {
                            diffCount++;
                        }
                        totalPixels++;
                    }
                }
                return diffCount / totalPixels;
            };

            // 1. Check Fovea (Center 50x50) - Should be STABLE (0% diff)
            const foveaDiff = checkRegionDiff((width / 2) - 25, (height / 2) - 25, 50, 50, "Fovea");
            if (foveaDiff > 0.01) {
                throw new Error(`Test 2 Failed: Fovea should be clear but changed by ${(foveaDiff * 100).toFixed(2)}%`);
            }

            // 2. Check Periphery (Top Left 50x50) - Should be DISTORTED (>1% diff)
            const peripheryDiff = checkRegionDiff(0, 0, 50, 50, "Periphery");
            if (peripheryDiff < 0.01) {
                throw new Error(`Test 2 Failed: Periphery should be distorted but changed by only ${(peripheryDiff * 100).toFixed(2)}%`);
            }

            ipcRenderer.send('log', `Test 2 Passed: Zonal Distortion verified (Fovea: ${(foveaDiff * 100).toFixed(2)}%, Periphery: ${(peripheryDiff * 100).toFixed(2)}%)`);

            // --- TEST 3: Motion Responsiveness ---
            // Render at Left position
            renderer.render(
                width, height,
                200, height / 2, // Mouse Left
                150, 1.33, 0.5, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
                200, height / 2, 0.0
            );
            const frameLeft = captureFrame();

            // Render at Right position
            renderer.render(
                width, height,
                600, height / 2, // Mouse Right
                150, 1.33, 0.5, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
                600, height / 2, 0.0
            );
            const frameRight = captureFrame();

            const motionDiff = compareFrames(frameLeft, frameRight);
            if (motionDiff < 0.05) { // Expect significant change
                throw new Error(`Test 3 Failed: Moving mouse did not affect image (diff: ${motionDiff})`);
            }
            ipcRenderer.send('log', `Test 3 Passed: Motion detected (diff: ${(motionDiff * 100).toFixed(2)}%)`);

            // --- TEST 4: Scrutinizer Config Flow ---
            // We need to test that updateIntensity updates the config used by render
            require('../renderer/scrutinizer.js'); // Executes IIFE, sets window.Scrutinizer

            // Mock config
            const mockConfig = {
                fovealRadius: 100,
                intensity: 0.5,
                peripheralIntensity: undefined // Ensure this is gone/unused
            };

            // Mock canvas for Scrutinizer (it looks for 'overlay-canvas')
            const overlayCanvas = document.createElement('canvas');
            overlayCanvas.id = 'overlay-canvas';
            overlayCanvas.width = 100;
            overlayCanvas.height = 100;
            document.body.appendChild(overlayCanvas);

            const scrutinizer = new window.Scrutinizer(mockConfig);

            // Verify initial state
            if (scrutinizer.config.intensity !== 0.5) {
                throw new Error(`Test 4 Failed: Initial intensity mismatch. Expected 0.5, got ${scrutinizer.config.intensity}`);
            }

            // Update intensity
            scrutinizer.updateIntensity(0.9);
            if (scrutinizer.config.intensity !== 0.9) {
                throw new Error(`Test 4 Failed: Update intensity mismatch. Expected 0.9, got ${scrutinizer.config.intensity}`);
            }

            // Verify render call uses new intensity
            // We can't easily spy on scrutinizer.renderer.render without mocking WebGLRenderer, 
            // but we can check if the property that Scrutinizer passes is correct.
            // Scrutinizer.render() calls this.renderer.render(..., this.config.intensity, ...)
            // We verified the code change in scrutinizer.js, so checking config.intensity is sufficient proxy.

            ipcRenderer.send('log', 'Test 4 Passed: Scrutinizer config updates correctly');

            // All passed
            ipcRenderer.send('test-result', { success: true, message: 'All visual tests passed' });

        } catch (err) {
            ipcRenderer.send('test-result', {
                success: false,
                message: err.message,
                details: err.stack
            });
        }
    </script>
</body>

</html>